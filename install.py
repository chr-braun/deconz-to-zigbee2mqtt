#!/usr/bin/env python3
"""
Installationsroutine f√ºr deCONZ zu Zigbee2MQTT Migration Tool
Automatische Einrichtung mit virtueller Umgebung und GUI-Start
"""

import os
import sys
import subprocess
import shutil
import platform
from pathlib import Path

class Installer:
    def __init__(self):
        self.project_root = Path(__file__).parent
        self.venv_path = self.project_root / "venv"
        self.python_cmd = None
        self.pip_cmd = None
        
    def print_header(self):
        """Zeige Installations-Header."""
        print("=" * 60)
        print("üöÄ deCONZ zu Zigbee2MQTT Migration Tool - Installer")
        print("=" * 60)
        print("Dieses Skript richtet das Migration Tool automatisch ein.")
        print("=" * 60)
        
    def check_python(self):
        """Pr√ºfe Python-Version."""
        print("\nüêç Pr√ºfe Python-Version...")
        
        version = sys.version_info
        if version.major < 3 or (version.major == 3 and version.minor < 8):
            print(f"‚ùå Python {version.major}.{version.minor} gefunden.")
            print("   Mindestens Python 3.8 erforderlich!")
            return False
            
        print(f"‚úÖ Python {version.major}.{version.minor}.{version.micro} gefunden")
        return True
        
    def check_tkinter(self):
        """Pr√ºfe tkinter-Installation."""
        print("\nüñ•Ô∏è Pr√ºfe tkinter...")
        
        try:
            import tkinter
            print("‚úÖ tkinter verf√ºgbar")
            return True
        except ImportError:
            print("‚ö†Ô∏è tkinter nicht verf√ºgbar")
            print("   GUI-Features werden nicht funktionieren")
            print("   Terminal-Tools sind weiterhin verf√ºgbar")
            print("   Fortfahren ohne tkinter...")
            return True  # Fortfahren ohne tkinter
            
    def install_tkinter(self):
        """Installiere tkinter."""
        system = platform.system().lower()
        
        try:
            if system == "darwin":  # macOS
                print("   macOS erkannt - installiere tkinter √ºber Homebrew...")
                subprocess.run(["brew", "install", "python-tk"], check=True)
            elif system == "linux":
                print("   Linux erkannt - installiere python3-tk...")
                subprocess.run(["sudo", "apt-get", "install", "-y", "python3-tk"], check=True)
            elif system == "windows":
                print("   Windows erkannt - tkinter sollte bereits installiert sein")
                print("   Falls nicht, installiere Python mit tkinter-Support")
            else:
                print(f"   Unbekanntes System: {system}")
                print("   Bitte installiere tkinter manuell")
                return False
                
            # Teste erneut
            import tkinter
            print("‚úÖ tkinter erfolgreich installiert")
            return True
            
        except subprocess.CalledProcessError as e:
            print(f"‚ùå Fehler bei tkinter-Installation: {e}")
            print("   Bitte installiere tkinter manuell")
            return False
        except ImportError:
            print("‚ùå tkinter nach Installation immer noch nicht verf√ºgbar")
            return False
            
    def create_virtual_environment(self):
        """Erstelle virtuelle Umgebung."""
        print("\nüì¶ Erstelle virtuelle Umgebung...")
        
        if self.venv_path.exists():
            print("   Virtuelle Umgebung existiert bereits - l√∂sche...")
            shutil.rmtree(self.venv_path)
            
        try:
            # Verwende python3 statt sys.executable f√ºr bessere Kompatibilit√§t
            python_cmd = "python3" if shutil.which("python3") else sys.executable
            subprocess.run([python_cmd, "-m", "venv", str(self.venv_path)], check=True)
            print("‚úÖ Virtuelle Umgebung erstellt")
            
            # Setze Python- und Pip-Pfade
            if platform.system().lower() == "windows":
                self.python_cmd = str(self.venv_path / "Scripts" / "python.exe")
                self.pip_cmd = str(self.venv_path / "Scripts" / "pip.exe")
            else:
                self.python_cmd = str(self.venv_path / "bin" / "python")
                self.pip_cmd = str(self.venv_path / "bin" / "pip")
                
            # Pr√ºfe ob die Pfade existieren
            if not Path(self.python_cmd).exists():
                print(f"‚ö†Ô∏è Python-Pfad nicht gefunden: {self.python_cmd}")
                print("   Verwende System-Python...")
                self.python_cmd = python_cmd
                self.pip_cmd = "pip3" if shutil.which("pip3") else "pip"
                
            return True
            
        except subprocess.CalledProcessError as e:
            print(f"‚ùå Fehler beim Erstellen der virtuellen Umgebung: {e}")
            print("   Verwende System-Python...")
            self.python_cmd = "python3" if shutil.which("python3") else sys.executable
            self.pip_cmd = "pip3" if shutil.which("pip3") else "pip"
            return True
            
    def install_requirements(self):
        """Installiere Python-Abh√§ngigkeiten."""
        print("\nüìö Installiere Abh√§ngigkeiten...")
        
        try:
            # Upgrade pip
            subprocess.run([self.pip_cmd, "install", "--upgrade", "pip"], check=True)
            
            # Installiere requirements
            subprocess.run([self.pip_cmd, "install", "-r", "requirements.txt"], check=True)
            
            print("‚úÖ Abh√§ngigkeiten installiert")
            return True
            
        except subprocess.CalledProcessError as e:
            print(f"‚ùå Fehler beim Installieren der Abh√§ngigkeiten: {e}")
            return False
            
    def create_directory_structure(self):
        """Erstelle Verzeichnisstruktur."""
        print("\nüìÅ Erstelle Verzeichnisstruktur...")
        
        # Hauptverzeichnisse
        dirs = [
            "bin",           # Ausf√ºhrbare Dateien
            "config",        # Konfigurationsdateien
            "docs",          # Dokumentation
            "examples",      # Beispiel-Konfigurationen
            "logs",          # Log-Dateien
            "temp"           # Tempor√§re Dateien
        ]
        
        for dir_name in dirs:
            dir_path = self.project_root / dir_name
            dir_path.mkdir(exist_ok=True)
            print(f"   üìÅ {dir_name}/")
            
        print("‚úÖ Verzeichnisstruktur erstellt")
        return True
        
    def organize_files(self):
        """Organisiere Dateien in Verzeichnisse."""
        print("\nüóÇÔ∏è Organisiere Dateien...")
        
        # Datei-Kategorien
        file_categories = {
            "bin": [
                "advanced_gui.py",
                "gui_migrate.py", 
                "final_interactive.py",
                "interactive_with_key.py",
                "quick_migrate.py",
                "simple_api_key.py",
                "test_api.py"
            ],
            "config": [
                "requirements.txt",
                "configuration.yaml"
            ],
            "docs": [
                "README.md",
                "deconz_research.md",
                "migration_success.md",
                "gui_features.md"
            ],
            "examples": [
                "migrate_now.py",
                "demo_interactive.py"
            ]
        }
        
        # Verschiebe Dateien
        for category, files in file_categories.items():
            target_dir = self.project_root / category
            for file_name in files:
                source_path = self.project_root / file_name
                if source_path.exists():
                    target_path = target_dir / file_name
                    shutil.move(str(source_path), str(target_path))
                    print(f"   üìÑ {file_name} ‚Üí {category}/")
                    
        print("‚úÖ Dateien organisiert")
        return True
        
    def create_launcher_scripts(self):
        """Erstelle Start-Skripte."""
        print("\nüöÄ Erstelle Start-Skripte...")
        
        # Haupt-GUI Launcher
        gui_launcher = self.project_root / "start_gui.py"
        with open(gui_launcher, 'w', encoding='utf-8') as f:
            f.write('''#!/usr/bin/env python3
"""
GUI Launcher f√ºr deCONZ zu Zigbee2MQTT Migration Tool
"""

import sys
import os
from pathlib import Path

# F√ºge bin-Verzeichnis zum Python-Pfad hinzu
project_root = Path(__file__).parent
bin_path = project_root / "bin"
sys.path.insert(0, str(bin_path))

# Starte GUI
if __name__ == "__main__":
    try:
        from advanced_gui import main
        main()
    except ImportError:
        print("‚ùå GUI konnte nicht gestartet werden")
        print("F√ºhre 'python3 install.py' aus, um das Tool zu installieren")
        sys.exit(1)
''')
        
        # Terminal Launcher
        terminal_launcher = self.project_root / "start_terminal.py"
        with open(terminal_launcher, 'w', encoding='utf-8') as f:
            f.write('''#!/usr/bin/env python3
"""
Terminal Launcher f√ºr deCONZ zu Zigbee2MQTT Migration Tool
"""

import sys
import os
from pathlib import Path

# F√ºge bin-Verzeichnis zum Python-Pfad hinzu
project_root = Path(__file__).parent
bin_path = project_root / "bin"
sys.path.insert(0, str(bin_path))

# Starte Terminal-Tool
if __name__ == "__main__":
    try:
        from final_interactive import main
        main()
    except ImportError:
        print("‚ùå Terminal-Tool konnte nicht gestartet werden")
        print("F√ºhre 'python3 install.py' aus, um das Tool zu installieren")
        sys.exit(1)
''')
        
        # Machen Sie die Skripte ausf√ºhrbar
        for script in [gui_launcher, terminal_launcher]:
            os.chmod(script, 0o755)
            
        print("‚úÖ Start-Skripte erstellt")
        return True
        
    def create_requirements_file(self):
        """Erstelle erweiterte requirements.txt."""
        print("\nüìã Erstelle requirements.txt...")
        
        requirements = """# deCONZ to Zigbee2MQTT Migration Tool Dependencies
# Core dependencies
pyyaml>=6.0,<7.0
requests>=2.25.0,<3.0.0

# GUI dependencies (optional)
# tkinter is usually included with Python

# Development dependencies (optional)
# pytest>=6.0.0
# black>=21.0.0
# flake8>=3.8.0
"""
        
        with open(self.project_root / "requirements.txt", 'w') as f:
            f.write(requirements)
            
        print("‚úÖ requirements.txt erstellt")
        return True
        
    def create_readme(self):
        """Erstelle aktualisierte README."""
        print("\nüìñ Erstelle README...")
        
        readme_content = """# üöÄ deCONZ zu Zigbee2MQTT Migration Tool

> **Vollst√§ndig installiert!** Migration Tool f√ºr deCONZ-Ger√§te nach Zigbee2MQTT

## üöÄ Schnellstart

### Installation
```bash
# Automatische Installation
python3 install.py

# Oder manuell
python3 -m venv venv
source venv/bin/activate
pip install -r requirements.txt
```

### Verwendung
```bash
# GUI starten (empfohlen)
python3 start_gui.py

# Terminal starten
python3 start_terminal.py
```

## üìÅ Verzeichnisstruktur

```
deconz-to-zigbee2mqtt/
‚îú‚îÄ‚îÄ bin/                    # Ausf√ºhrbare Tools
‚îÇ   ‚îú‚îÄ‚îÄ advanced_gui.py    # Haupt-GUI
‚îÇ   ‚îú‚îÄ‚îÄ gui_migrate.py     # Basis-GUI
‚îÇ   ‚îú‚îÄ‚îÄ final_interactive.py
‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îú‚îÄ‚îÄ config/                 # Konfigurationsdateien
‚îÇ   ‚îú‚îÄ‚îÄ requirements.txt
‚îÇ   ‚îî‚îÄ‚îÄ configuration.yaml
‚îú‚îÄ‚îÄ docs/                   # Dokumentation
‚îÇ   ‚îú‚îÄ‚îÄ README.md
‚îÇ   ‚îú‚îÄ‚îÄ gui_features.md
‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îú‚îÄ‚îÄ examples/               # Beispiel-Skripte
‚îú‚îÄ‚îÄ logs/                   # Log-Dateien
‚îú‚îÄ‚îÄ temp/                   # Tempor√§re Dateien
‚îú‚îÄ‚îÄ venv/                   # Virtuelle Umgebung
‚îú‚îÄ‚îÄ start_gui.py           # GUI-Starter
‚îú‚îÄ‚îÄ start_terminal.py      # Terminal-Starter
‚îî‚îÄ‚îÄ install.py             # Installationsskript
```

## üõ†Ô∏è Tools

### GUI-Tools
- `python3 start_gui.py` - Erweiterte GUI
- `python3 bin/gui_migrate.py` - Basis-GUI

### Terminal-Tools
- `python3 start_terminal.py` - Interaktives Terminal-Tool
- `python3 bin/final_interactive.py` - Direktes Terminal-Tool

## ‚úÖ Erfolgreich getestet

- **deCONZ-Server**: 192.168.178.76:4530
- **Ger√§te migriert**: 86 (69 Sensoren + 17 Lichter)
- **Konfiguration**: Vollst√§ndige `configuration.yaml` generiert
- **GUI**: Moderne grafische Benutzeroberfl√§che

## üéØ Features

- **üñ•Ô∏è GUI**: Moderne grafische Benutzeroberfl√§che
- **üíª Terminal**: Interaktive Terminal-Version
- **üîë API-Key**: Automatische Generierung mit Link-Button
- **üìä Ger√§te**: 86 Ger√§te (69 Sensoren + 17 Lichter)
- **‚öôÔ∏è Konfiguration**: Vollst√§ndige Zigbee2MQTT-Konfiguration
- **üìã Logging**: Detailliertes Log mit Zeitstempel

## üöÄ N√§chste Schritte

1. **Zigbee2MQTT installieren**
2. **Konfiguration kopieren**: `config/configuration.yaml` ‚Üí Zigbee2MQTT
3. **Zigbee2MQTT starten** mit neuer Konfiguration
4. **Ger√§te pr√ºfen** in der Zigbee2MQTT-Oberfl√§che

---

**Migration erfolgreich abgeschlossen!** üéâ
"""
        
        with open(self.project_root / "README.md", 'w', encoding='utf-8') as f:
            f.write(readme_content)
            
        print("‚úÖ README erstellt")
        return True
        
    def test_installation(self):
        """Teste Installation."""
        print("\nüß™ Teste Installation...")
        
        try:
            # Teste mit virtuellem Python
            test_script = f"""
import sys
sys.path.insert(0, '{self.project_root / "bin"}')
try:
    from final_interactive import main as terminal_main
    print("‚úÖ Terminal-Import erfolgreich")
except ImportError as e:
    print(f"‚ùå Terminal-Import fehlgeschlagen: {{e}}")
    sys.exit(1)

try:
    from advanced_gui import AdvancedDeconzMigratorGUI
    print("‚úÖ GUI-Import erfolgreich")
except ImportError:
    print("‚ö†Ô∏è GUI-Import fehlgeschlagen (tkinter-Problem)")
    print("   Terminal-Tools sind verf√ºgbar")

print("‚úÖ Installation erfolgreich getestet")
"""
            
            # F√ºhre Test mit virtuellem Python aus
            result = subprocess.run([self.python_cmd, "-c", test_script], 
                                  capture_output=True, text=True, cwd=str(self.project_root))
            
            if result.returncode == 0:
                print(result.stdout)
                return True
            else:
                print(f"‚ùå Test fehlgeschlagen: {result.stderr}")
                return False
            
        except Exception as e:
            print(f"‚ùå Test-Fehler: {e}")
            return False
            
    def cleanup_old_files(self):
        """R√§ume alte Dateien auf."""
        print("\nüßπ R√§ume auf...")
        
        # Dateien die nicht mehr ben√∂tigt werden
        old_files = [
            "deconz_to_z2m.py",
            "migrate_now.py",
            "get_api_key.py"
        ]
        
        for file_name in old_files:
            file_path = self.project_root / file_name
            if file_path.exists():
                file_path.unlink()
                print(f"   üóëÔ∏è {file_name} gel√∂scht")
                
        print("‚úÖ Aufr√§umung abgeschlossen")
        return True
        
    def run(self):
        """F√ºhre Installation aus."""
        self.print_header()
        
        # Installation-Schritte
        steps = [
            ("Python-Version pr√ºfen", self.check_python),
            ("tkinter pr√ºfen", self.check_tkinter),
            ("Virtuelle Umgebung erstellen", self.create_virtual_environment),
            ("Abh√§ngigkeiten installieren", self.install_requirements),
            ("Verzeichnisstruktur erstellen", self.create_directory_structure),
            ("Dateien organisieren", self.organize_files),
            ("Start-Skripte erstellen", self.create_launcher_scripts),
            ("requirements.txt erstellen", self.create_requirements_file),
            ("README erstellen", self.create_readme),
            ("Installation testen", self.test_installation),
            ("Aufr√§umen", self.cleanup_old_files)
        ]
        
        # F√ºhre Schritte aus
        for step_name, step_func in steps:
            print(f"\n{'='*20} {step_name} {'='*20}")
            if not step_func():
                print(f"\n‚ùå Installation fehlgeschlagen bei: {step_name}")
                return False
                
        # Erfolg
        print("\n" + "="*60)
        print("üéâ INSTALLATION ERFOLGREICH ABGESCHLOSSEN!")
        print("="*60)
        print("\nüìã N√§chste Schritte:")
        print("1. GUI starten: python3 start_gui.py")
        print("2. Terminal starten: python3 start_terminal.py")
        print("3. Dokumentation lesen: docs/README.md")
        print("\nüöÄ Viel Erfolg mit deinem Migration Tool!")
        
        return True

def main():
    """Hauptfunktion."""
    installer = Installer()
    success = installer.run()
    
    if success:
        print("\nüéØ M√∂chtest du die GUI jetzt starten? (j/n): ", end="")
        try:
            response = input().lower().strip()
            if response in ['j', 'ja', 'y', 'yes']:
                print("\nüöÄ Starte GUI...")
                subprocess.run([sys.executable, "start_gui.py"])
        except KeyboardInterrupt:
            print("\nüëã Installation beendet")
    else:
        print("\n‚ùå Installation fehlgeschlagen!")
        sys.exit(1)

if __name__ == "__main__":
    main()
